use anyhow::Result;
use image::imageops::FilterType;
use image::io::Reader as ImageReader;
use image::{DynamicImage, GenericImageView, ImageBuffer, Rgba, ImageOutputFormat};
use palette::{FromColor, Lab, Srgb};
use palette::color_difference::Ciede2000;
use std::path::{Path, PathBuf};
use std::io::Cursor;

// --- GENERIC PUBLIC STRUCTS ---

/// Represents a final grouped color cluster found in the image.
///
/// This struct holds the color definition in both LAB (for calculation)
/// and Hex/RGBA (for display), along with its prevalence in the image.
#[derive(Debug, Clone)]
pub struct ColorCluster {
    /// The center color of this cluster in CIELAB space.
    pub lab: Lab,
    /// The number of pixels in the image belonging to this cluster.
    pub count: usize,
    /// The percentage of the total valid image area this cluster represents.
    pub percentage: f32,
    /// The hexadecimal color code string (e.g., "#FF0000").
    pub hex: String,
    /// The RGBA values for visualization (e.g., [255, 0, 0, 255]).
    pub rgba: [u8; 4],
}

/// Represents a "Superpixel" generated by the SLIC algorithm.
///
/// A superpixel is a perceptually coherent group of spatially connected pixels.
/// It serves as a pre-processing step to reduce the complexity of K-Means clustering.
#[derive(Debug, Clone, Copy)]
pub struct Superpixel {
    /// The L component of the average color (Lightness).
    pub l: f32, 
    /// The A component of the average color (Green-Red).
    pub a: f32, 
    /// The B component of the average color (Blue-Yellow).
    pub b: f32,
    /// The X coordinate of the superpixel center.
    pub x: f32, 
    /// The Y coordinate of the superpixel center.
    pub y: f32,
    /// The number of raw pixels absorbed into this superpixel.
    pub count: usize,
    /// The unique ID of this superpixel (used for labeling pixels).
    pub id: usize,
}

/// Holds all intermediate and final data from the analysis pipeline.
///
/// This struct is primarily used to pass data into the visualization generator,
/// allowing it to render the original image, the segmentation map, and the palette.
pub struct ProcessingResult {
    /// The original image loaded from input.
    pub original_img: DynamicImage,
    /// The resized and blurred version used for the actual mathematical analysis.
    pub processed_img: DynamicImage,
    /// An array mapping every pixel index to a final cluster index.
    pub segmentation_map: Vec<usize>,
    /// An array mapping every pixel index to a Superpixel ID.
    pub labels: Vec<usize>,
    /// The list of all Superpixels generated (internal use).
    pub _superpixels: Vec<Superpixel>,
    /// The final list of dominant color clusters (the palette).
    pub clusters: Vec<ColorCluster>,
}

// Holds the raw data needed for UI highlighting
pub struct AnalysisData {
    pub clusters: Vec<ColorCluster>,
    pub width: u32,
    pub height: u32,
    pub map: Vec<u8>, // Flattened array: Pixel index -> Cluster ID
}

// --- GENERIC IMAGE LOADING ---

/// Loads an image from a file path.
///
/// # Arguments
/// * `path` - The filesystem path to the image.
///
/// # Returns
/// A `DynamicImage` or an error if the file cannot be opened or decoded.
pub fn load_image_from_path(path: &Path) -> Result<DynamicImage> {
    let img = ImageReader::open(path)
        .map_err(|e| anyhow::anyhow!("Failed to open file: {}", e))?
        .decode()
        .map_err(|e| anyhow::anyhow!("Failed to decode image: {}", e))?;
    Ok(img)
}

/// Loads an image from raw bytes.
///
/// This is useful for mobile integration where image data might come from
/// a camera stream, a gallery picker, or a network request.
///
/// # Arguments
/// * `bytes` - A byte slice containing encoded image data (JPEG, PNG, etc.).
pub fn load_image_from_bytes(bytes: &[u8]) -> Result<DynamicImage> {
    let img = image::load_from_memory(bytes)
        .map_err(|e| anyhow::anyhow!("Failed to decode image bytes: {}", e))?;
    Ok(img)
}

// --- CORE PIPELINE FUNCTIONS ---

/// Prepares a smaller, blurred version of the image for analysis.
///
/// This step is crucial for performance and noise reduction.
///
/// # Arguments
/// * `img` - The source image.
/// * `max_dim` - The maximum width or height. The image maintains aspect ratio.
/// * `blur_sigma` - The sigma value for Gaussian blur (removes texture details).
pub fn preprocess_image(img: &DynamicImage, max_dim: u32, blur_sigma: f32) -> DynamicImage {
    let (orig_w, orig_h) = img.dimensions();
    let scale = max_dim as f32 / (orig_w.max(orig_h) as f32);
    let new_w = (orig_w as f32 * scale).round() as u32;
    let new_h = (orig_h as f32 * scale).round() as u32;

    let scaled = img.resize(new_w, new_h, FilterType::Gaussian);
    let blurred_buffer = image::imageops::blur(&scaled, blur_sigma);
    DynamicImage::ImageRgba8(blurred_buffer)
}

/// Converts an image's pixels from RGB to the CIELAB color space.
///
/// LAB is used because Euclidean distance in this space corresponds much better
/// to human perceptual color difference than in RGB.
pub fn rgb_to_lab(img: &DynamicImage) -> Vec<Lab> {
    img.pixels()
        .map(|(_, _, rgba)| {
            let srgb = Srgb::new(rgba[0] as f32/255.0, rgba[1] as f32/255.0, rgba[2] as f32/255.0);
            Lab::from_color(srgb)
        })
        .collect()
}

/// Runs the SLIC (Simple Linear Iterative Clustering) algorithm.
///
/// Generates superpixels based on color similarity and spatial proximity.
///
/// # Arguments
/// * `pixels` - The LAB pixel data.
/// * `width`, `height` - Image dimensions.
/// * `k` - Approximate number of superpixels to generate (target count).
/// * `compactness` - Balance between color similarity and spatial regularity.
///   Higher values make superpixels more square/regular.
///
/// # Returns
/// A tuple `(Labels, Superpixels)`. `Labels` is a vector where `labels[i]` is
/// the Superpixel ID for pixel `i`.
pub fn slic_segmentation(pixels: &[Lab], width: usize, height: usize, k: usize, compactness: f32) -> (Vec<usize>, Vec<Superpixel>) {
    let mut labels = vec![0usize; width * height];
    let mut distances = vec![f32::MAX; width * height];
    
    let step = ((width * height) as f32 / k as f32).sqrt().round() as usize;
    let mut centers = Vec::new();
    
    // Init Centers on a grid
    for y in (step/2..height).step_by(step) {
        for x in (step/2..width).step_by(step) {
            let idx = y * width + x;
            let p = pixels[idx];
            centers.push(Superpixel {
                l: p.l, a: p.a, b: p.b,
                x: x as f32, y: y as f32,
                count: 0, id: centers.len()
            });
        }
    }

    // Iterate to refine centers (10 passes)
    for _ in 0..10 {
        distances.fill(f32::MAX);

        for center in &centers {
            // Search in a 2S x 2S window around the center
            let y_min = (center.y - step as f32).max(0.0) as usize;
            let y_max = (center.y + step as f32).min(height as f32) as usize;
            let x_min = (center.x - step as f32).max(0.0) as usize;
            let x_max = (center.x + step as f32).min(width as f32) as usize;

            for y in y_min..y_max {
                for x in x_min..x_max {
                    let idx = y * width + x;
                    let p = pixels[idx];

                    // SLIC Distance Metric: Color Distance + Spatial Distance
                    let dc_sq = (p.l - center.l).powi(2) + (p.a - center.a).powi(2) + (p.b - center.b).powi(2);
                    let ds_sq = (x as f32 - center.x).powi(2) + (y as f32 - center.y).powi(2);
                    let dist = (dc_sq + (compactness / step as f32).powi(2) * ds_sq).sqrt();

                    if dist < distances[idx] {
                        distances[idx] = dist;
                        labels[idx] = center.id;
                    }
                }
            }
        }

        // Update Centers based on average of assigned pixels
        let mut new_centers = vec![Superpixel { l:0.0, a:0.0, b:0.0, x:0.0, y:0.0, count:0, id:0 }; centers.len()];
        for (i, label) in labels.iter().enumerate() {
            let c = &mut new_centers[*label];
            let p = pixels[i];
            let x = (i % width) as f32;
            let y = (i / width) as f32;
            c.l += p.l; c.a += p.a; c.b += p.b;
            c.x += x; c.y += y;
            c.count += 1;
            c.id = *label;
        }

        for (i, center) in centers.iter_mut().enumerate() {
            let nc = &new_centers[i];
            if nc.count > 0 {
                let inv = 1.0 / nc.count as f32;
                center.l = nc.l * inv;
                center.a = nc.a * inv;
                center.b = nc.b * inv;
                center.x = nc.x * inv;
                center.y = nc.y * inv;
                center.count = nc.count;
            }
        }
    }

    (labels, centers)
}

/// Runs K-Means clustering on the generated Superpixels.
///
/// # Arguments
/// * `superpixels` - The list of superpixels generated by SLIC.
/// * `k` - The target number of clusters (palette size).
///
/// # Returns
/// A vector of `ColorCluster` structs representing the centroids.
pub fn cluster_colors(superpixels: &[Superpixel], k: usize) -> Vec<ColorCluster> {
    // Prepare data: filter out empty/invalid superpixels
    let mut valid_lab_data: Vec<Lab> = Vec::new();
    for sp in superpixels.iter() {
        if sp.count > 0 {
            valid_lab_data.push(Lab::new(sp.l, sp.a, sp.b));
        }
    }

    if valid_lab_data.is_empty() {
        return Vec::new();
    }

    let kmeans_result = kmeans_colors::get_kmeans(
        k, 20, 1.0, false, &valid_lab_data, 42,
    );

    kmeans_result.centroids.iter().map(|centroid| {
        let srgb: Srgb = Srgb::from_color(*centroid);
        let u8_color: Srgb<u8> = srgb.into_format();
        ColorCluster {
            lab: *centroid,
            count: 0,
            percentage: 0.0,
            hex: format!("#{:02x}{:02x}{:02x}", u8_color.red, u8_color.green, u8_color.blue),
            rgba: [u8_color.red, u8_color.green, u8_color.blue, 255],
        }
    }).collect()
}

/// Merges clusters that are perceptually very similar.
///
/// # Arguments
/// * `clusters` - The raw clusters found by K-Means.
/// * `threshold` - The Delta E distance below which two colors are merged.
pub fn merge_colors(clusters: Vec<ColorCluster>, threshold: f32) -> Vec<ColorCluster> {
    let mut result = Vec::new();
    let mut merged_mask = vec![false; clusters.len()];

    for i in 0..clusters.len() {
        if merged_mask[i] { continue; }

        // Weighted average accumulators
        let mut weighted_l = clusters[i].lab.l * clusters[i].count as f32;
        let mut weighted_a = clusters[i].lab.a * clusters[i].count as f32;
        let mut weighted_b = clusters[i].lab.b * clusters[i].count as f32;
        let mut total_count = clusters[i].count;
        
        if total_count == 0 { 
            weighted_l = clusters[i].lab.l;
            weighted_a = clusters[i].lab.a;
            weighted_b = clusters[i].lab.b;
            total_count = 1;
        }

        merged_mask[i] = true;

        for j in (i + 1)..clusters.len() {
            if merged_mask[j] { continue; }
            let distance = clusters[i].lab.difference(clusters[j].lab);
            if distance < threshold {
                let weight = if clusters[j].count > 0 { clusters[j].count } else { 1 };
                weighted_l += clusters[j].lab.l * weight as f32;
                weighted_a += clusters[j].lab.a * weight as f32;
                weighted_b += clusters[j].lab.b * weight as f32;
                total_count += weight;
                merged_mask[j] = true;
            }
        }

        let new_lab = Lab::new(
            weighted_l / total_count as f32, 
            weighted_a / total_count as f32, 
            weighted_b / total_count as f32
        );
        let srgb: Srgb = Srgb::from_color(new_lab);
        let u8_color: Srgb<u8> = srgb.into_format();

        result.push(ColorCluster {
            lab: new_lab,
            count: 0, // Will be recalculated in create_segmentation_map
            percentage: 0.0,
            hex: format!("#{:02x}{:02x}{:02x}", u8_color.red, u8_color.green, u8_color.blue),
            rgba: [u8_color.red, u8_color.green, u8_color.blue, 255],
        });
    }
    result
}

/// Maps every pixel in the image to the closest color in the merged palette.
///
/// This performs a nearest-neighbor search for every pixel against the final clusters.
/// It also updates the `count` property of the clusters based on actual pixel usage.
///
/// # Arguments
/// * `labels` - The SLIC label for each pixel.
/// * `superpixels` - The list of superpixel data.
/// * `clusters` - The merged list of color clusters (palette).
/// * `total_pixels` - Total number of pixels in the image.
///
/// # Returns
/// A vector representing the "segmentation map" (pixel index -> cluster index).
pub fn create_segmentation_map(
    labels: &[usize], 
    superpixels: &[Superpixel], 
    clusters: &mut [ColorCluster],
    total_pixels: usize
) -> Vec<usize> {
    let mut map = vec![0usize; total_pixels];
    
    // Reset counts
    for c in clusters.iter_mut() { c.count = 0; }

    for (i, label) in labels.iter().enumerate() {
        let sp = &superpixels[*label];
        let sp_lab = Lab::new(sp.l, sp.a, sp.b);

        let mut best_index = 0;
        let mut min_dist = f32::MAX;

        for (c_idx, cluster) in clusters.iter().enumerate() {
            let dist = sp_lab.difference(cluster.lab);
            if dist < min_dist {
                min_dist = dist;
                best_index = c_idx;
            }
        }
        
        clusters[best_index].count += 1;
        map[i] = best_index;
    }
    map
}

/// Calculates percentage statistics and filters insignificant clusters.
///
/// It removes clusters that represent less than 3% of the image area and sorts
/// the remaining clusters by dominance.
pub fn calculate_final_clusters(clusters: &mut Vec<ColorCluster>) -> Vec<ColorCluster> {
    let total_valid: usize = clusters.iter().map(|c| c.count).sum();
    for c in clusters.iter_mut() {
        c.percentage = (c.count as f32 / total_valid as f32) * 100.0;
    }

    // Filter Small Clusters (< 3%)
    let (mut large_clusters, small_clusters): (Vec<ColorCluster>, Vec<ColorCluster>) = 
        clusters.clone().into_iter().partition(|c| c.percentage >= 3.0);
    
    if large_clusters.is_empty() { large_clusters = small_clusters; }
    large_clusters.sort_by(|a, b| b.count.cmp(&a.count));

    large_clusters
}

/// Helper to generate the output filename (e.g., "image_result.png") based on input path.
pub fn generate_output_path(input_path: &Path) -> PathBuf {
    let file_stem = input_path.file_stem().unwrap().to_string_lossy();
    let parent = input_path.parent().unwrap();
    parent.join(format!("{}_result.png", file_stem))
}

/// Generates a visualization image (PNG) from the processing results.
/// Returns the PNG file as a vector of bytes, which can be saved to disk
/// or displayed directly in a UI.
pub fn generate_visualization_bytes(data: &ProcessingResult) -> Result<Vec<u8>> {
    let (width, height) = data.processed_img.dimensions();
    let col_width = 300;
    let aspect_ratio = height as f32 / width as f32;
    let canvas_height = (col_width as f32 * aspect_ratio).round() as u32;
    // 5 Columns: Original, Processed, Segmented, Boundaries, Palette
    let canvas_width = col_width * 5; 

    let mut canvas = ImageBuffer::new(canvas_width, canvas_height);

    let mut draw_col = |col_idx: u32, img: &DynamicImage, filter: FilterType| {
        let resized = img.resize(col_width, canvas_height, filter);
        let x_off = (col_idx * col_width) + (col_width - resized.width()) / 2;
        let y_off = (canvas_height - resized.height()) / 2;
        image::imageops::overlay(&mut canvas, &resized, x_off as i64, y_off as i64);
    };

    // 1. Original
    draw_col(0, &data.original_img, FilterType::Triangle);
    // 2. Processed (Blurred)
    draw_col(1, &data.processed_img, FilterType::Nearest);

    // 3. Segmented (Solid Colors)
    let mut segmented_img = ImageBuffer::new(width, height);
    // 4. Boundaries (Yellow Lines)
    let mut boundaries_img = data.processed_img.to_rgba8();
    let yellow = Rgba([255, 255, 0, 255]);

    for y in 0..height {
        for x in 0..width {
            let idx = (y * width + x) as usize;
            let best_idx = data.segmentation_map[idx];
            segmented_img.put_pixel(x, y, Rgba(data.clusters[best_idx].rgba));

            // Draw Boundaries
            let current_label = data.labels[idx];
            if x + 1 < width && data.labels[idx + 1] != current_label {
                boundaries_img.put_pixel(x, y, yellow);
            }
            if y + 1 < height && data.labels[idx + width as usize] != current_label {
                boundaries_img.put_pixel(x, y, yellow);
            }
        }
    }

    draw_col(2, &DynamicImage::ImageRgba8(segmented_img), FilterType::Nearest);
    draw_col(3, &DynamicImage::ImageRgba8(boundaries_img), FilterType::Nearest);

    // 5. Palette Swatches
    let mut draw_rect = |x_s: u32, y_s: u32, w: u32, h: u32, col: [u8; 4]| {
        for y in y_s..(y_s + h).min(canvas_height) {
            for x in x_s..(x_s + w).min(canvas_width) {
                canvas.put_pixel(x, y, Rgba(col));
            }
        }
    };

    let display_clusters: Vec<&ColorCluster> = data.clusters.iter().take(5).collect();
    if !display_clusters.is_empty() {
        let swatch_h = canvas_height / display_clusters.len() as u32;
        for (i, c) in display_clusters.iter().enumerate() {
            draw_rect(col_width * 4, i as u32 * swatch_h, col_width, swatch_h, c.rgba);
        }
    }

    // Write to Memory Buffer (PNG)
    let mut bytes: Vec<u8> = Vec::new();
    let mut cursor = Cursor::new(&mut bytes);
    canvas.write_to(&mut cursor, ImageOutputFormat::Png)?;
    Ok(bytes)
}

// --- HIGH LEVEL GENERIC API ---

/// A generic wrapper that takes a loaded image and runs the full analysis pipeline.
///
/// This function abstracts the steps of:
/// 1. Preprocessing
/// 2. SLIC Segmentation
/// 3. Clustering
/// 4. Merging
/// 5. Stats Calculation
/// 6. Visualization generation
///
/// # Arguments
/// * `img` - The loaded `DynamicImage`.
/// * `k` - The number of initial clusters to search for.
///
/// # Returns
/// A tuple containing:
/// * `Vec<ColorCluster>` - The final sorted list of dominant colors.
/// * `Vec<u8>` - The bytes of the generated visualization PNG.
pub fn run_analysis(
    img: DynamicImage, 
    k: usize, 
    max_dim: Option<u32>,
    blur_sigma: Option<f32>
) -> Result<ProcessingResult>{
    // 1. Preprocess (Resize & Blur)
    let target_dim = max_dim.unwrap_or(600);
    let target_sigma = blur_sigma.unwrap_or(2.0);
    let processed_img = preprocess_image(&img, target_dim, target_sigma);
    let (width, height) = processed_img.dimensions();

    // 2. SLIC & Clustering
    let lab_pixels = rgb_to_lab(&processed_img);
    let (labels, superpixels) = slic_segmentation(&lab_pixels, width as usize, height as usize, 300, 20.0);
    let raw_clusters = cluster_colors(&superpixels, k);

    // 3. Merge & Refine
    let mut merged_clusters = merge_colors(raw_clusters, 15.0);

    // Create temp map to populate counts
    let _ = create_segmentation_map(
        &labels, &superpixels, &mut merged_clusters, width as usize * height as usize
    );

    // Filter small clusters (<3%)
    let mut final_clusters = calculate_final_clusters(&mut merged_clusters);

    // 4. Final Map Generation
    // This maps every pixel to the final, filtered palette
    let final_segmentation_map = create_segmentation_map(
        &labels, &superpixels, &mut final_clusters, width as usize * height as usize
    );

    // Return the RICH object
    Ok(ProcessingResult {
        original_img: img,
        processed_img: DynamicImage::ImageRgba8(processed_img.to_rgba8()),
        segmentation_map: final_segmentation_map,
        labels,
        _superpixels: superpixels,
        clusters: final_clusters,
    })
}